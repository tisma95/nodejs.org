---
layout: about.hbs
title: Аб праекце
trademark: Гандлёвая марка
---

# Аб Node.js®

Node.js — гэта падзейна-арыентаванае асінхроннае асяроддзе выканання JavaScript-кода, спраектаванае для стварэння маштабуемых сеткавых праграм. Ніжэй прыведзены прыклад "hello world", які можа адначасова апрацоўваць шмат злучэнняў. Для кожнага злучэння выклікаецца функцыя зваротнага выкліку, але калі злучэнняў няма, Node.js "засынае".

```javascript
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Гэта адрозніваецца ад сённяшняй больш распаўсюджанай мадэлі паралелізму, у якой выкарыстоўваюцца патокі АС. Камунікацыя, заснаваная на патоках, з'яўляецца адносна неэфектыўнай і вельмі цяжкай у выкарыстанні. Больш за тое, карыстальнікі Node.js могуць не турбавацца аб блакіроўках працэсаў, паколькі іх не існуе. Амаль ніводная функцыя ў Node.js не працуе напрамую з уводам/вывадам, таму працэс ніколі не блакіруецца, за выключэннем выпадкаў, калі ўвод/вывад выконваецца з выкарыстаннем сінхронных метадаў стандартнай бібліятэкі Node.js. Такім чынам, паколькі нішто не блакіруецца, вельмі мэтазгодна распрацоўваць маштабуемыя сістэмы на Node.js.

Больш падрабязна з гэтым падыходам можна азнаёміцца ў поўным артыкуле [Blocking vs. Non-Blocking][].

---

Node.js быў створаны пад уплывам такіх сістэм, як [Event Machine][] у Ruby і [Twisted][] у Python. Але пры гэтым падзейная сістэма ў ім выкарыстоўваецца значна шырэй: [цыкл падзей][] з'яўляецца часткай асяроддзя выканання, а не асобнай бібліятэкай. У іншых сістэмах заўсёды існуе блакіруючы выклік для запуску цыкла падзей. Звычайна, логіка праграмы вызначаецца праз зваротныя выклікі (callbacks) у пачатку скрыпта, а ў канцы праз блакіруючы выклік, напрыклад `EventMachine::run()`, запускаецца серверная частка. У Node.js няма нічога падобнага на выклік пачатку цыкла падзей. Node.js проста ўваходзіць у цыкл падзей пасля запуску скрыпта і выходзіць з цыкла, калі больш не застаецца зарэгістраваных функцый зваротнага выкліку. Гэта падобна на працу JavaScript у браўзеры, дзе цыкл падзей схаваны ад карыстальніка.

HTTP — важны элемент Node.js, распрацаваны з улікам паточнасці і малой затрымкі. Гэта робіць Node.js добрай асновай для вэб-бібліятэкі ці фрэймворка.

Тое, што Node.js спраектаваны без выкарыстання патокаў, зусім не азначае, што вы не зможаце скарыстацца перавагамі свайго шмат’ядзернага працоўнага асяроддзя. Даччыныя працэсы можна ствараць з дапамогай нашага API [`child_process.fork()`][]. Даччыныя працэсы спраектаваны так, каб з імі было лёгка ўзаемадзейнічаць. На аснове таго ж інтэрфейсу пабудаваны модуль [`cluster`][], які дазваляе размяркоўваць сокеты паміж працэсамі, каб збалансаваць нагрузку на ядры вашай сістэмы.

[Blocking vs. Non-Blocking]: /en/docs/guides/blocking-vs-non-blocking/
[`child_process.fork()`]: https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options
[`cluster`]: https://nodejs.org/api/cluster.html
[цыкл падзей]: /en/docs/guides/event-loop-timers-and-nexttick/
[Event Machine]: https://github.com/eventmachine/eventmachine
[Twisted]: https://twistedmatrix.com/trac/
