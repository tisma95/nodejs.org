---
layout: about.hbs
title: Про проєкт
trademark: Товарний знак
---

# Про Node.js®

Як асинхронне подієво-орієнтоване середовище виконання JavaScript, Node.js призначений для створення масштабованих мережевих додатків. У наступному прикладі "Привіт, світе!" багато з'єднань можуть оброблятися одночасно. При кожному з'єднанні викликається зворотний виклик, але якщо немає роботи для виконання, Node.js буде перебувати у режимі сну.

```javascript
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Це контрастує з більш поширеною моделлю, в якій використовуються OS потоки. Мережеве програмування на основі потоків є відносно неефективним та дуже складним у використанні. Більше того, користувачі Node.js можуть не турбуватись про блокування процесів, оскільки вони відсутні. Майже жодна функція в Node.js не виконує безпосередніх операцій введення-виведення (I/O), тому процес ніколи не блокується, за винятком випадків, коли I/O виконується за допомогою синхронних методів стандартної бібліотеки Node.js. Оскільки нічого не блокується, розробка масштабованих систем на Node.js є дуже обґрунтованою.

Якщо деякі з цих термінів незнайомі, то можете переглянути повну статтю на [Blocking vs Non-Blocking][].

---

Node.js схожий у своєму дизайні з такими системами, як Ruby's [Event Machine][] та Python's [Twisted][]. Node.js використовує подієву модель значно ширше, він представляє [цикл подій][] як конструкцію виконання часу роботи, а не як бібліотеку. В інших системах завжди є блокуючий виклик для запуску циклу подій. Зазвичай поведінка визначається через зворотні виклики в початку скрипта, а на кінці сервер запускається через блокуючий виклик, подібний до `EventMachine::run()`. У Node.js немає такого виклику для запуску циклу подій. Node.js просто входить у цикл подій після виконання вхідного скрипта. Node.js виходить з ціклу подій, коли немає більше зворотних викликів для виконання. Ця поведінка схожа на JavaScript у браузері: цикл подій прихований від користувача.

HTTP є основним елементом у Node.js, розроблений з урахуванням потокового та низького часу затримки. Це робить Node.js хорошою основою для веббібліотек або фреймворку.

Те, що Node.js, розроблений без використання потоків, не означає, що ви не можете скористатися перевагами багатоядерного середовища. Дочірні процеси можуть бути створені за допомогою нашого API [`child_process.fork()`][] і розроблені для зручного взаємодії. На основі цього ж інтерфейсу побудований модуль [`cluster`][], який дозволяє спільно використовувати сокети між процесами для розподілу навантаження на ваші ядра.

[Blocking vs Non-Blocking]: /en/docs/guides/blocking-vs-non-blocking/
[`child_process.fork()`]: https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options
[`cluster`]: https://nodejs.org/api/cluster.html
[цикл подій]: /en/docs/guides/event-loop-timers-and-nexttick/
[Event Machine]: https://github.com/eventmachine/eventmachine
[Twisted]: https://twistedmatrix.com/trac/
